{"version":3,"file":"CheapWatch.es.js","sources":["../node_modules/cheap-watch/dist/CheapWatch.es.js"],"sourcesContent":["import * as EventEmitter from 'events';\nimport { readdir, stat, watch } from 'fs';\nimport { promisify } from 'util';\n\nconst readdir$1 = promisify(readdir);\nconst stat$1 = promisify(stat);\nclass CheapWatch extends EventEmitter {\n    constructor(data) {\n        super();\n        this.watch = true;\n        this.debounce = 10;\n        this.paths = new Map();\n        this._watchers = new Map();\n        this._timeouts = new Map();\n        this._queue = [];\n        this._status = 0;\n        Object.assign(this, data);\n        if (typeof this.dir !== 'string') {\n            throw new TypeError('dir must be a string');\n        }\n        if (this.filter && typeof this.filter !== 'function') {\n            throw new TypeError('filter must be a function');\n        }\n        if (typeof this.watch !== 'boolean') {\n            throw new TypeError('watch must be a boolean');\n        }\n        if (typeof this.debounce !== 'number') {\n            throw new TypeError('debounce must be a number');\n        }\n    }\n    async init() {\n        if (this._status !== 0) {\n            throw new Error('cannot call init() twice');\n        }\n        this._status = 1;\n        await this._recurse(this.dir);\n        this._status = 2;\n    }\n    close() {\n        if (this._status === 0 || this._status === 1) {\n            throw new Error('cannot call close() before init() finishes');\n        }\n        if (this._status === 4) {\n            throw new Error('cannot call close() twice');\n        }\n        this._status = 4;\n        for (const watcher of this._watchers.values()) {\n            watcher.close();\n        }\n    }\n    async _recurse(full) {\n        const path = full.slice(this.dir.length + 1);\n        const stats = await stat$1(full);\n        if (path) {\n            if (this.filter && !(await this.filter({ path, stats }))) {\n                return;\n            }\n            this.paths.set(path, stats);\n        }\n        if (stats.isDirectory()) {\n            if (this.watch) {\n                this._watchers.set(path, watch(full, this._handle.bind(this, full)).on('error', () => { }));\n            }\n            await Promise.all((await readdir$1(full)).map(sub => this._recurse(full + '/' + sub)));\n        }\n    }\n    _handle(dir, event, file) {\n        this._debounce(dir);\n        this._debounce(dir + '/' + file);\n    }\n    _debounce(path) {\n        if (this._timeouts.has(path)) {\n            clearTimeout(this._timeouts.get(path));\n        }\n        this._timeouts.set(path, setTimeout(() => {\n            this._timeouts.delete(path);\n            this._enqueue(path);\n        }, this.debounce));\n    }\n    async _enqueue(full) {\n        this._queue.push(full);\n        if (this._status !== 2) {\n            return;\n        }\n        this._status = 3;\n        while (this._queue.length) {\n            const full = this._queue.shift();\n            const path = full.slice(this.dir.length + 1);\n            const stats = await stat$1(full).catch(() => { });\n            if (stats) {\n                if (this.filter && !(await this.filter({ path, stats }))) {\n                    continue;\n                }\n                const isNew = !this.paths.has(path);\n                this.paths.set(path, stats);\n                if (path) {\n                    this.emit('+', { path, stats, isNew });\n                }\n                if (stats.isDirectory() && !this._watchers.has(path)) {\n                    await this._recurse(full);\n                    for (const [newPath, stats] of this.paths.entries()) {\n                        if (newPath.startsWith(path + '/')) {\n                            this.emit('+', { path: newPath, stats, isNew: true });\n                        }\n                    }\n                }\n            }\n            else if (this.paths.has(path)) {\n                const stats = this.paths.get(path);\n                this.paths.delete(path);\n                this.emit('-', { path, stats });\n                if (this._watchers.has(path)) {\n                    for (const old of this._watchers.keys()) {\n                        if (old === path || old.startsWith(path + '/')) {\n                            this._watchers.get(old).close();\n                            this._watchers.delete(old);\n                        }\n                    }\n                    for (const old of this.paths.keys()) {\n                        if (old.startsWith(path + '/')) {\n                            const stats = this.paths.get(old);\n                            this.paths.delete(old);\n                            this.emit('-', { path: old, stats });\n                        }\n                    }\n                }\n            }\n        }\n        this._status = 2;\n    }\n}\n\nexport default CheapWatch;\n//# sourceMappingURL=CheapWatch.es.js.map\n"],"names":[],"mappings":";;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}